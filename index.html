<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tournament Bracket Generator (Standalone)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Tournament Bracket Generator</h1>

    <section class="row">
      <div class="card">
        <h2>Import / Export</h2>
        <div class="controls">
          <button id="exportBtn">Export Bracket</button>
          <input id="importFile" type="file" accept="application/json">
        </div>
      </div>
<!-- comment -->
      <div class="card">
        <h2>Sets</h2>
        <div class="two-col">
          <div>
            <h3>Players (<span id="playerCount">0</span>)</h3>
            <textarea id="playerInput" placeholder="Paste players here, one per line"></textarea>
            <button id="addPlayerBtn">Add</button>
            <ul id="playersList"></ul>
          </div>
          <div>
            <h3>Decks (<span id="deckCount">0</span>)</h3>
            <textarea id="deckInput" placeholder="Paste decks here, one per line"></textarea>
            <button id="adddeckBtn">Add</button>
            <ul id="decksList"></ul>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Options</h2>
        <label>
          Tournament type:
          <select id="tournamentType">
            <option value="single">Single Elimination</option>
            <option value="double">Double Elimination (not fully supported)</option>
            <option value="roundrobin">Round Robin</option>
          </select>
        </label>
        <div class="controls">
          <button id="generateBtn">Generate Tournament</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
    </section>

    <section id="bracketArea"></section>

    <section class="card">
      <h2>Player View</h2>
      <label>
        Select player:
        <select id="playerViewSelect"><option value="">-- choose --</option></select>
      </label>
      <div id="playerOpponents"></div>
    </section>

    <section class="card">
      <h2>Leaderboards</h2>
      <div class="two-col">
        <div>
          <h3>Players</h3>
          <ol id="playerLeaderboard"></ol>
        </div>
        <div>
          <h3>Decks</h3>
          <ol id="deckLeaderboard"></ol>
        </div>
      </div>
      <div class="controls">
        <button id="generateTiebreakersBtn">Generate Tiebreakers (1st/2nd/3rd)</button>
      </div>
    </section>

    <section id="tiebreakerArea"></section>

    <footer>
      Built for local use — double-click index.html to open. Styles in styles.css.
    </footer>
  </div>

<script>
/*
Standalone Tournament Bracket Generator
Features:
- Add players (Set A) and decks (Set B)
- Generate single-elim or round-robin brackets
- Randomize decks per round (no duplicate deck in same round)
- BYE handling (no decks for BYE, BYE cannot win)
- Pick winners (buttons disabled after pick)
- Player view showing opponents & decks per round (includes BYE)
- Leaderboards sorted most->least wins
- Tiebreakers for 1st/2nd/3rd as separate single-elim tournaments with minimal matches
- Export/Import JSON of full state
*/

(function() {
  // State
  let players = [];
  let decks = [];
  let tournamentType = 'single';
  let rounds = []; // array of rounds; each round is array of matches {p1,p2,c1,c2,winner}
  let results = { players: {}, decks: {} };
  let tiebreakers = { first: null, second: null, third: null }; // each is {players,decks,rounds}

  // Elements
  const playersList = document.getElementById('playersList');
  const decksList = document.getElementById('decksList');
  const playerInput = document.getElementById('playerInput');
  const deckInput = document.getElementById('deckInput');
  const addPlayerBtn = document.getElementById('addPlayerBtn');
  const adddeckBtn = document.getElementById('adddeckBtn');
  const generateBtn = document.getElementById('generateBtn');
  const resetBtn = document.getElementById('resetBtn');
  const bracketArea = document.getElementById('bracketArea');
  const playerViewSelect = document.getElementById('playerViewSelect');
  const playerOpponents = document.getElementById('playerOpponents');
  const playerLeaderboard = document.getElementById('playerLeaderboard');
  const deckLeaderboard = document.getElementById('deckLeaderboard');
  const generateTiebreakersBtn = document.getElementById('generateTiebreakersBtn');
  const tiebreakerArea = document.getElementById('tiebreakerArea');
  const exportBtn = document.getElementById('exportBtn');
  const importFile = document.getElementById('importFile');
  const tournamentTypeSelect = document.getElementById('tournamentType');
  const deckHistory = {};  // Example: deckHistory[playerName] = new Set(['Deck A', 'Deck B']);


  // Helpers
  const uniquePush = (arr, v) => { if (!arr.includes(v)) arr.push(v); };
  const shuffle = (arr) => arr.slice().sort(() => Math.random() - 0.5);
  const ensureEvenWithBye = (arr) => { const copy = arr.slice(); if (copy.length %2 === 1) copy.push('BYE'); return copy; };
  const DEFAULT_TOURNAMENT = {
  "players": [
    "Adlai",
    "Brett",
    "Aaron Saunders",
    "Kate Kemichick",
    "Kelsey Lumsden",
    "Garrett",
    "Maddy Goodman",
    "Patrick Kenny",
    "Rick Pease",
    "Sophia Abraham",
    "Alex Zettler",
    "Patricia Huang"
  ],
  "decks": [
    "Jason Kemichick",
    "Sean Kirschke",
    "Trav",
    "Jacob",
    "Jacob F1",
    "Jacob F2",
    "Jacob F3",
    "Daryl",
    "Deck 1",
    "Deck 2",
    "Deck 3",
    "Deck 4"
  ],
  "tournamentType": "roundrobin",
  "rounds": [
    [
      {
        "p1": "Adlai",
        "p2": "Patricia Huang",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Brett",
        "p2": "Alex Zettler",
        "c1": "Deck 1",
        "c2": "Deck 2",
        "winner": null
      },
      {
        "p1": "Aaron Saunders",
        "p2": "Sophia Abraham",
        "c1": "Jacob F1",
        "c2": "Daryl",
        "winner": null
      },
      {
        "p1": "Kate Kemichick",
        "p2": "Rick Pease",
        "c1": "Jacob F3",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Kelsey Lumsden",
        "p2": "Patrick Kenny",
        "c1": "Jacob",
        "c2": "Jacob F2",
        "winner": null
      },
      {
        "p1": "Garrett",
        "p2": "Maddy Goodman",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Alex Zettler",
        "c1": "Deck 3",
        "c2": "Deck 4",
        "winner": null
      },
      {
        "p1": "Patricia Huang",
        "p2": "Sophia Abraham",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Brett",
        "p2": "Rick Pease",
        "c1": "Trav",
        "c2": "Daryl",
        "winner": null
      },
      {
        "p1": "Aaron Saunders",
        "p2": "Patrick Kenny",
        "c1": "Jacob F3",
        "c2": "Jacob F2",
        "winner": null
      },
      {
        "p1": "Kate Kemichick",
        "p2": "Maddy Goodman",
        "c1": "Jacob F1",
        "c2": "Jacob",
        "winner": null
      },
      {
        "p1": "Kelsey Lumsden",
        "p2": "Garrett",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Sophia Abraham",
        "c1": "Jason Kemichick",
        "c2": "Deck 4",
        "winner": null
      },
      {
        "p1": "Alex Zettler",
        "p2": "Rick Pease",
        "c1": "Deck 3",
        "c2": "Deck 2",
        "winner": null
      },
      {
        "p1": "Patricia Huang",
        "p2": "Patrick Kenny",
        "c1": "Deck 1",
        "c2": "Daryl",
        "winner": null
      },
      {
        "p1": "Brett",
        "p2": "Maddy Goodman",
        "c1": "Jacob F3",
        "c2": "Jacob F2",
        "winner": null
      },
      {
        "p1": "Aaron Saunders",
        "p2": "Garrett",
        "c1": "Jacob F1",
        "c2": "Jacob",
        "winner": null
      },
      {
        "p1": "Kate Kemichick",
        "p2": "Kelsey Lumsden",
        "c1": "Trav",
        "c2": "Sean Kirschke",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Rick Pease",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Sophia Abraham",
        "p2": "Patrick Kenny",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Alex Zettler",
        "p2": "Maddy Goodman",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Patricia Huang",
        "p2": "Garrett",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Brett",
        "p2": "Kelsey Lumsden",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Aaron Saunders",
        "p2": "Kate Kemichick",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Patrick Kenny",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Rick Pease",
        "p2": "Maddy Goodman",
        "c1": "Deck 2",
        "c2": "Daryl",
        "winner": null
      },
      {
        "p1": "Sophia Abraham",
        "p2": "Garrett",
        "c1": "Deck 1",
        "c2": "Jacob F2",
        "winner": null
      },
      {
        "p1": "Alex Zettler",
        "p2": "Kelsey Lumsden",
        "c1": "Jacob F3",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Patricia Huang",
        "p2": "Kate Kemichick",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Brett",
        "p2": "Aaron Saunders",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Maddy Goodman",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Patrick Kenny",
        "p2": "Garrett",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Rick Pease",
        "p2": "Kelsey Lumsden",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Sophia Abraham",
        "p2": "Kate Kemichick",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Alex Zettler",
        "p2": "Aaron Saunders",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Patricia Huang",
        "p2": "Brett",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Garrett",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Maddy Goodman",
        "p2": "Kelsey Lumsden",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Patrick Kenny",
        "p2": "Kate Kemichick",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Rick Pease",
        "p2": "Aaron Saunders",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Sophia Abraham",
        "p2": "Brett",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Alex Zettler",
        "p2": "Patricia Huang",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Kelsey Lumsden",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Garrett",
        "p2": "Kate Kemichick",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Maddy Goodman",
        "p2": "Aaron Saunders",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Patrick Kenny",
        "p2": "Brett",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Rick Pease",
        "p2": "Patricia Huang",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Sophia Abraham",
        "p2": "Alex Zettler",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Kate Kemichick",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Kelsey Lumsden",
        "p2": "Aaron Saunders",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Garrett",
        "p2": "Brett",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Maddy Goodman",
        "p2": "Patricia Huang",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Patrick Kenny",
        "p2": "Alex Zettler",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Rick Pease",
        "p2": "Sophia Abraham",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Aaron Saunders",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Kate Kemichick",
        "p2": "Brett",
        "c1": "Deck 2",
        "c2": "Deck 1",
        "winner": null
      },
      {
        "p1": "Kelsey Lumsden",
        "p2": "Patricia Huang",
        "c1": "Daryl",
        "c2": "Jacob F3",
        "winner": null
      },
      {
        "p1": "Garrett",
        "p2": "Alex Zettler",
        "c1": "Jacob F2",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Maddy Goodman",
        "p2": "Sophia Abraham",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Patrick Kenny",
        "p2": "Rick Pease",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ],
    [
      {
        "p1": "Adlai",
        "p2": "Brett",
        "c1": "Deck 4",
        "c2": "Deck 3",
        "winner": null
      },
      {
        "p1": "Aaron Saunders",
        "p2": "Patricia Huang",
        "c1": "Deck 2",
        "c2": "Daryl",
        "winner": null
      },
      {
        "p1": "Kate Kemichick",
        "p2": "Alex Zettler",
        "c1": "Deck 1",
        "c2": "Jacob F2",
        "winner": null
      },
      {
        "p1": "Kelsey Lumsden",
        "p2": "Sophia Abraham",
        "c1": "Jacob F3",
        "c2": "Jacob F1",
        "winner": null
      },
      {
        "p1": "Garrett",
        "p2": "Rick Pease",
        "c1": "Jacob",
        "c2": "Trav",
        "winner": null
      },
      {
        "p1": "Maddy Goodman",
        "p2": "Patrick Kenny",
        "c1": "Sean Kirschke",
        "c2": "Jason Kemichick",
        "winner": null
      }
    ]
  ],
  "results": {
    "players": {},
    "decks": {}
  },
  "tiebreakers": {
    "first": null,
    "second": null,
    "third": null
  }
};

  window.addEventListener("DOMContentLoaded", () => {
    importTournamentObject(DEFAULT_TOURNAMENT);
  });

  // UI updates
  function refreshLists() {
    playersList.innerHTML = '';
    players.forEach(p => {
      const li = document.createElement('li');
      li.textContent = p;
      playersList.appendChild(li);
    });
  
  // Update player counter
  const pc = document.getElementById('playerCount');
  if (pc) pc.textContent = players.length;
  
    decksList.innerHTML = '';
    decks.forEach(c => {
      const li = document.createElement('li');
      li.textContent = c;
      decksList.appendChild(li);
    });

  // Update deck counter
  const cc = document.getElementById('deckCount');
  if (cc) cc.textContent = decks.length;

    // player view select
    playerViewSelect.innerHTML = '<option value=\"\">-- choose --</option>';
    players.forEach(p => {
      const opt = document.createElement('option'); opt.value = p; opt.textContent = p;
      playerViewSelect.appendChild(opt);
    });
  }

  function resetState() {
    rounds = [];
    results = { players: {}, decks: {} };
    tiebreakers = { first: null, second: null, third: null };
    bracketArea.innerHTML = '';
    tiebreakerArea.innerHTML = '';
    updateLeaderboards();
    renderPlayerView();
  }

  function updateLeaderboards() {
    playerLeaderboard.innerHTML = '';
    deckLeaderboard.innerHTML = '';
    const sortedPlayers = Object.entries(results.players).sort((a,b)=>b[1]-a[1]);
    sortedPlayers.forEach(([p,w])=>{
      const li = document.createElement('li'); li.textContent = `${p}: ${w} win(s)`; playerLeaderboard.appendChild(li);
    });
    const sorteddecks = Object.entries(results.decks).sort((a,b)=>b[1]-a[1]);
    sorteddecks.forEach(([c,w])=>{
      const li = document.createElement('li'); li.textContent = `${c}: ${w} win(s)`; deckLeaderboard.appendChild(li);
    });
  }

  // Match generation ensuring deck uniqueness per round
  function assigndecksForRound(matchPlayers) {
    const available = shuffle(decks);
    const assignments = {};
    let idx = 0;
    matchPlayers.forEach(p => {
      if (p === 'BYE') { assignments[p] = 'No deck'; return; }
      assignments[p] = available[idx % available.length] || 'No deck';
      idx++;
    });
    return assignments;
  }

  function generateSingleElim(initialPlayers) {
    const realPlayers = initialPlayers.filter(p => p !== 'BYE');
    const arr = ensureEvenWithBye(shuffle(realPlayers));
    const shuffleddecks = shuffle(decks);
    const matches = [];
    // assign decks ensuring no duplicate in same round by popping decks
    const decksPool = shuffle(decks);
    for (let i=0;i<arr.length;i+=2){
      const p1 = arr[i]; const p2 = arr[i+1] || 'BYE';
      const c1 = (p1 !== 'BYE' && decksPool.length) ? decksPool.pop() : 'No deck';
      const c2 = (p2 !== 'BYE' && decksPool.length) ? decksPool.pop() : 'No deck';
      matches.push({p1,p2,c1,c2,winner:null});
    }
    return [matches];
  }

function generateRoundRobin(playersList) {
  const temp = playersList.slice();
  if (temp.length % 2 === 1) temp.push('BYE');
  const roundsLocal = [];
  const n = temp.length;
  // Initialize history tracking
  temp.forEach(p => {
    if (p !== 'BYE' && !deckHistory[p]) deckHistory[p] = new Set();
  });
  for (let r = 0; r < n - 1; r++) {
    const roundMatches = [];
    // Create a fresh copy of deck list
    const availableDecks = [...decks];
    // Assign decks to players in this round
    function getDeckForPlayer(player) {
      if (player === 'BYE') return 'No deck';
      // Filter out decks this player has already used
      const unusedDecks = availableDecks.filter(d => !deckHistory[player].has(d));
      let chosen = null;
      if (unusedDecks.length > 0) {
        // Prefer unused deck
        shuffle(unusedDecks);
        chosen = unusedDecks.pop();
      } else {
        // All decks used — repeats now allowed
        shuffle(availableDecks);
        chosen = availableDecks.pop();
      }
      // Remove from available pool
      const idx = availableDecks.indexOf(chosen);
      if (idx !== -1) availableDecks.splice(idx, 1);
      // Remember assignment
      deckHistory[player].add(chosen);
      return chosen;
    }
    // Build matches
    for (let i = 0; i < n / 2; i++) {
      const p1 = temp[i];
      const p2 = temp[n - 1 - i];
      const c1 = getDeckForPlayer(p1);
      const c2 = getDeckForPlayer(p2);
      roundMatches.push({ p1, p2, c1, c2, winner: null });
    }
    roundsLocal.push(roundMatches);
    // Rotate array (Round Robin algorithm)
    temp.splice(1, 0, temp.pop());
  }
  return roundsLocal;
}


  // Render bracket rounds
  function renderBracket() {
    bracketArea.innerHTML = '';
    rounds.forEach((roundMatches, rIdx) => {
      const card = document.createElement('div'); card.className='card';
      const h = document.createElement('h3'); h.textContent = 'Round ' + (rIdx+1); card.appendChild(h);
      const grid = document.createElement('div'); grid.className='grid';
      roundMatches.forEach((m, mIdx)=>{
        const matchDiv = document.createElement('div'); matchDiv.className='match';
        const left = document.createElement('div'); left.innerHTML = `<strong>${m.p1}</strong> <span class="muted">(${m.c1})</span>`;
        const right = document.createElement('div'); right.innerHTML = `<strong>${m.p2}</strong> <span class="muted">(${m.c2})</span>`;
        matchDiv.appendChild(left); matchDiv.appendChild(document.createElement('div')).textContent='vs'; matchDiv.appendChild(right);
        if (m.p1==='BYE' || m.p2==='BYE') {
          const bye = document.createElement('div'); bye.className='muted'; bye.textContent='BYE - No winner assigned'; matchDiv.appendChild(bye);
        } else {
          const btns = document.createElement('div'); btns.className='match-btns';
          const b1 = document.createElement('button'); b1.textContent = 'Winner: ' + m.p1; b1.disabled = !!m.winner;
          const b2 = document.createElement('button'); b2.textContent = 'Winner: ' + m.p2; b2.disabled = !!m.winner;
          b1.addEventListener('click', ()=> pickWinner(rIdx,mIdx,m.p1,m.c1));
          b2.addEventListener('click', ()=> pickWinner(rIdx,mIdx,m.p2,m.c2));
          btns.appendChild(b1); btns.appendChild(b2); matchDiv.appendChild(btns);
        }
        if (m.winner) {
          const win = document.createElement('div'); win.className='winner'; win.textContent = 'Winner: ' + m.winner; matchDiv.appendChild(win);
        }
        grid.appendChild(matchDiv);
      });
      card.appendChild(grid);
      bracketArea.appendChild(card);
    });
  }

  function pickWinner(roundIndex, matchIndex, winner, deck) {
    const match = rounds[roundIndex][matchIndex];
    if (match.winner || match.p1==='BYE' || match.p2==='BYE') return;
    match.winner = winner;
    results.players[winner] = (results.players[winner]||0)+1;
    if (deck && deck!=='No deck') results.decks[deck] = (results.decks[deck]||0)+1;
    // advance if elimination
    if (tournamentType !== 'roundrobin') {
      const current = rounds[roundIndex];
      const allDecided = current.every(m=> m.winner || m.p2==='BYE');
      if (allDecided) {
        const nextPlayers = current.map(m=> m.winner).filter(p=> p && p!=='BYE');
        if (nextPlayers.length>0){
          const nextRound = generateSingleElim(nextPlayers)[0];
          rounds.push(nextRound);
        }
      }
    }
    updateLeaderboards();
    renderBracket();
    renderPlayerView();
  }

  function renderPlayerView() {
    playerOpponents.innerHTML = '';
    const selected = playerViewSelect.value;
    if (!selected) return;
    const list = [];
    rounds.forEach((r, idx)=>{
      r.forEach(m=>{
        if (m.p1===selected || m.p2===selected) {
          const opponent = (m.p1===selected) ? m.p2 : m.p1;
          const deck = (m.p1===selected) ? m.c1 : m.c2;
          const oppdeck = (m.p1===selected) ? m.c2 : m.c1;
          list.push({round: idx+1, opponent, deck, oppdeck});
        }
      });
    });
    if (list.length===0) playerOpponents.textContent = 'No matches yet';
    list.forEach(it=>{
      const card = document.createElement('div'); card.className='small-card';
      card.innerHTML = `<strong>Round ${it.round}</strong><div>Opponent: ${it.opponent} ${it.opponent==='BYE' ? '(BYE)' : ''} <span class="muted">(${it.oppdeck})</span></div><div>Your deck: <span class="muted">${it.deck}</span></div>`;
      playerOpponents.appendChild(card);
    });
  }

  // Tiebreakers: create minimal single-elim brackets for tied groups
  function generateTiebreakers() {
    const playerScores = Object.entries(results.players);
    const deckScores = Object.entries(results.decks);
    function topThreeTies(entries) {
      if (!entries || entries.length===0) return {first:[],second:[],third:[]};
      const sorted = entries.slice().sort((a,b)=>b[1]-a[1]);
      const scores = [...new Set(sorted.map(e=>e[1]))];
      return {
        first: sorted.filter(e=> e[1]===scores[0]).map(e=>e[0] || []).filter(Boolean),
        second: scores[1] ? sorted.filter(e=> e[1]===scores[1]).map(e=>e[0]) : [],
        third: scores[2] ? sorted.filter(e=> e[1]===scores[2]).map(e=>e[0]) : []
      };
    }
    const pTies = topThreeTies(playerScores);
    const cTies = topThreeTies(deckScores);
    function buildTB(groupPlayers, groupdecks) {
      if (!groupPlayers || groupPlayers.length<=1) return null;
      // minimal single-elim: if odd, add BYE but BYE not allowed to win; decks assigned per round fairly
      const pool = groupPlayers.slice();
      if (pool.length%2===1) pool.push('BYE');
      const roundsLocal = [];
      let current = pool.slice();
      while (current.length>1) {
        const matches = [];
        const deckPool = shuffle(groupdecks || decks);
        for (let i=0;i<current.length;i+=2){
          const p1 = current[i], p2 = current[i+1] || 'BYE';
          const c1 = (p1!=='BYE' && deckPool.length)?deckPool.pop():'No deck';
          const c2 = (p2!=='BYE' && deckPool.length)?deckPool.pop():'No deck';
          matches.push({p1,p2,c1,c2,winner:null});
        }
        roundsLocal.push(matches);
        // prepare next: winners unknown yet - use placeholders; we'll not auto-advance until user picks winners
        current = matches.map(m=> m.winner || null).filter(Boolean);
        if (current.length===0) break; // stop building deeper rounds now, will build as winners selected
      }
      return roundsLocal;
    }
    tiebreakers.first = { players: pTies.first, decks: cTies.first, rounds: buildTB(pTies.first, cTies.first) };
    tiebreakers.second = { players: pTies.second, decks: cTies.second, rounds: buildTB(pTies.second, cTies.second) };
    tiebreakers.third = { players: pTies.third, decks: cTies.third, rounds: buildTB(pTies.third, cTies.third) };
    renderTiebreakers();
  }

  function renderTiebreakers() {
    tiebreakerArea.innerHTML = '';
    ['first','second','third'].forEach(place=>{
      const tb = tiebreakers[place];
      if (!tb || !tb.players || tb.players.length===0) return;
      const card = document.createElement('div'); card.className='card';
      const h = document.createElement('h3'); h.textContent = place.toUpperCase() + ' Place Tiebreaker';
      card.appendChild(h);
      const p = document.createElement('p'); p.textContent = 'Players: ' + (tb.players.join(', ') || '—'); card.appendChild(p);
      const pc = document.createElement('p'); pc.textContent = 'decks: ' + (tb.decks.join(', ') || '—'); card.appendChild(pc);
      if (tb.rounds && tb.rounds.length) {
        tb.rounds.forEach((r,ri)=>{
          const sub = document.createElement('div'); sub.className='small-card';
          sub.innerHTML = `<strong>Round ${ri+1}</strong>`;
          r.forEach((m,mi)=>{
            const mdiv = document.createElement('div'); mdiv.className='match';
            mdiv.innerHTML = `<div>${m.p1} <span class="muted">(${m.c1})</span> vs ${m.p2} <span class="muted">(${m.c2})</span></div>`;
            sub.appendChild(mdiv);
          });
          card.appendChild(sub);
        });
      } else {
        const note = document.createElement('div'); note.className='muted'; note.textContent = 'No tiebreaker matches generated yet — winners will be chosen in tiebreaker UI when available.';
        card.appendChild(note);
      }
      tiebreakerArea.appendChild(card);
    });
  }

  // Export / Import
  function exportState() {
    const data = { players, decks, tournamentType, rounds, results, tiebreakers };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'tournament_data.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ document.body.removeChild(a); URL.revokeObjectURL(url); }, 500);
  }

  function importState(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(String(reader.result));
        players = Array.isArray(data.players) ? data.players : (Array.isArray(data.setA) ? data.setA : []);
        decks = Array.isArray(data.decks) ? data.decks : (Array.isArray(data.setB) ? data.setB : []);
        tournamentType = data.tournamentType || 'single';
        rounds = Array.isArray(data.rounds) ? data.rounds : (Array.isArray(data.bracket) ? data.bracket : []);
        results = data.results || {players:{},decks:{}};
        tiebreakers = data.tiebreakers || { first: null, second: null, third: null };
        // sync UI
        tournamentTypeSelect.value = tournamentType;
        refreshLists(); renderBracket(); updateLeaderboards(); renderTiebreakers();
      } catch (err) {
        alert('Import failed: invalid file.');
      }
    };
    reader.onerror = ()=> alert('Failed to read file.');
    reader.readAsText(file);
  }

  // Event wiring
  addPlayerBtn.addEventListener('click', ()=> { addParticipantToState(); });
  adddeckBtn.addEventListener('click', ()=> { adddeckToState(); });
  playerInput.addEventListener('keydown', (e)=> { if (e.key==='Enter') addParticipantToState(); });
  deckInput.addEventListener('keydown', (e)=> { if (e.key==='Enter') adddeckToState(); });
  generateBtn.addEventListener('click', ()=> {
    tournamentType = tournamentTypeSelect.value;
    if (tournamentType === 'roundrobin') rounds = generateRoundRobin(players.slice());
    else rounds = generateSingleElim(players.slice());
    results = {players:{},decks:{}};
    tiebreakers = { first: null, second: null, third: null };
    renderBracket(); updateLeaderboards(); renderTiebreakers();
  });
  resetBtn.addEventListener('click', ()=> {
    players = []; decks = []; rounds = []; results = {players:{},decks:{}}; tiebreakers={first:null,second:null,third:null};
    refreshLists(); renderBracket(); updateLeaderboards(); renderTiebreakers();
  });
  playerViewSelect.addEventListener('change', renderPlayerView);
  generateTiebreakersBtn.addEventListener('click', ()=> { generateTiebreakers(); renderTiebreakers(); });
  exportBtn.addEventListener('click', exportState);
  importFile.addEventListener('change', (e)=> importState(e.target.files && e.target.files[0]));

function addParticipantToState() {
  const raw = (playerInput.value || '').trim();
  if (!raw) return;

  // Split on newlines → trim → remove empty → remove duplicates
  const names = raw
    .split(/\r?\n/)
    .map(n => n.trim())
    .filter(n => n && !players.includes(n));

  // Add them all
  players.push(...names);

  // Clear input and refresh
  playerInput.value = '';
  refreshLists();
}

function adddeckToState() {
  const raw = (deckInput.value || '').trim();
  if (!raw) return;

  const names = raw
    .split(/\r?\n/)
    .map(n => n.trim())
    .filter(n => n && !decks.includes(n));

  decks.push(...names);

  deckInput.value = '';
  refreshLists();
}

function importTournamentObject(obj) {
  players = Array.isArray(obj.players) ? obj.players : [];
  decks = Array.isArray(obj.decks) ? obj.decks : [];
  tournamentType = obj.tournamentType || 'roundrobin';

  rounds = Array.isArray(obj.rounds) ? obj.rounds : [];  
  results = obj.results || { players: {}, decks: {} };
  tiebreakers = obj.tiebreakers || { first: null, second: null, third: null };

  refreshLists();
  renderBracket();
  updateLeaderboards();
  renderTiebreakers();
  renderPlayerView();
}


  // initial refresh
  refreshLists();

  // expose for debugging
  window._tournament = { getState: ()=>({players,decks,tournamentType,rounds,results,tiebreakers}) };

})();

</script>


</body>
</html>
